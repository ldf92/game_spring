<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// which one is highlighted
start_menu_position = 1;
//1 - new game
//2 - load game
//3 - options
//4 - extras
//5 - quit

// the number of points on the 360' circle
number_of_menu_bars = 5;
number_of_point = number_of_menu_bars * 8;

// radius of the circle
radius = 500;

// coordinates of the center of the circle
x_of_center_of_circle = 900;
y_of_center_of_circle = 170;

// total and half degree of a circle
TOTAL_DEGREE_OF_CIRCLE = 360;
HALF_DEGREE_OF_CIRCLE = 180;

// index
index_start_game = 1;
index_load_game = 2;
index_options = 3;
index_credits = 4;
index_quit = 5;

// scales for resizing sprite
scale_x_big = 4;
scale_y_big = 2;
scale_x_small = 1.5;
scale_y_small = 1.5;

// which one is selected when user press enter or z
index_when_press_enter = 0;

// the indicator that if we need to move the sprite
// 1 - start, 2 - load, 3 - option, 4 - credits, 5 - quit
indicator_move = 0;

// the moving distance of sprite, the sprite will move when enter is clicked
global.moving_distance = 0;





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(room_credits);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(room_options);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(room_load);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_goto(room_game);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


// we need to calculate the points' coordinates

// the coordinates of the points on the circle, stored in array
vec_x = 0;
vec_y = 0;

// the angle between every two points
angle_per_point = TOTAL_DEGREE_OF_CIRCLE / number_of_point;

//index i
i = 0;

repeat (number_of_point)
{
    // the point array should start from the rightmost point on the circle
    angle = (i * angle_per_point + HALF_DEGREE_OF_CIRCLE) * pi / 180;
    vec_x[i] = radius * cos(angle) + x_of_center_of_circle;
    vec_y[i] = radius * sin(angle) + y_of_center_of_circle;
    i++;
}

//draw_text(20,40, start_menu_position);
//draw_text(20,80, vec_y[0]);



// making the selected bar bigger and move to the center
// draw_sprite_ext( sprite, subimg, x, y, xscale, yscale, rot, color, alpha );
// e.g. draw_self = draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha);

// the center of the circle (800, 170)
// start game should be (440, 240), which is (vec_x[0], vec_y[0])
// load game should be (450, 315), which is (vec_x[1], vec_y[1])

// the color for the description box
color_description_box = make_color_rgb(70,70,70);


// 1. draw start game (it would be bigger and red color, and opaque)

if(start_menu_position &gt;= 2)
{
    temp_index = start_menu_position - 2;
}
else
{
    temp_index = number_of_point - 1;
}

temp_x = vec_x[temp_index];
temp_y = vec_y[temp_index];
    
direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
image_angle = direction;

// draw it and resize, recolor
if(start_menu_position == index_start_game)
{
    // (1) draw the menu description rectangle
    draw_set_color(color_description_box);
    draw_rectangle(0, 500, 800, 537, false);
    draw_set_color(c_black);
    draw_text(10, 505, "Start a new game.");
    
    // (2) draw the bigger sprite
    // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_game
    if(index_when_press_enter == index_start_game)
    {
        //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
        //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
        if(global.moving_distance &lt; 200)
        {
            difference_x = abs(x_of_center_of_circle - temp_x);
            difference_y = abs(y_of_center_of_circle - temp_y);
            difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
            destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
            destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
            draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            draw_sprite_ext( spr_start_NewGame, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
            global.moving_distance += 5;
        }
        else
        {
            alarm[0] = 1;
        }
    }
    else
    {
        draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
    }
}
else
{
    // draw the smaller sprite
    draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
}

// 2. draw load game (it would be smaller and gray color and a little transparent)

temp_index --;

if(temp_index &lt; 0)
{
    temp_index += number_of_point;
}

temp_x = vec_x[temp_index];
temp_y = vec_y[temp_index];
direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
image_angle = direction;

// draw it and resize, recolor
if(start_menu_position == index_load_game)
{
    // (1) draw the menu description rectangle
    draw_set_color(color_description_box);
    draw_rectangle(0, 500, 800, 537, false);
    draw_set_color(c_black);
    draw_text(10, 505, "Load game from the old savings.");
    
    // (2) draw the bigger sprite
    // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_load

    if(index_when_press_enter == index_load_game)
    {
        //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
        //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
        if(global.moving_distance &lt; 200)
        {
            difference_x = abs(x_of_center_of_circle - temp_x);
            difference_y = abs(y_of_center_of_circle - temp_y);
            difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
            destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
            destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
            draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            draw_sprite_ext( spr_start_LoadGame, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
            global.moving_distance += 5;
        }
        else
        {
            alarm[1] = 1;
        }
    }
    else
    {
        draw_sprite_ext( spr_start_LoadGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
    }
}
else
{
    // draw the smaller sprite
    draw_sprite_ext( spr_start_LoadGame, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
}


// 3. draw options (it would be smaller and gray color and a little transparent)

temp_index --;

if(temp_index &lt; 0)
{
    temp_index += number_of_point;
}

temp_x = vec_x[temp_index];
temp_y = vec_y[temp_index];
direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
image_angle = direction;

// draw it and resize, recolor
if(start_menu_position == index_options)
{
    // (1) draw the menu description rectangle
    draw_set_color(color_description_box);
    draw_rectangle(0, 500, 800, 537, false);
    draw_set_color(c_black);
    draw_text(10, 505, "Change settings.");
    
    // (2) draw the bigger sprite
    // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_options
    
    if(index_when_press_enter == index_options)
    {
        //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
        //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
        if(global.moving_distance &lt; 200)
        {
            difference_x = abs(x_of_center_of_circle - temp_x);
            difference_y = abs(y_of_center_of_circle - temp_y);
            difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
            destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
            destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
            draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            draw_sprite_ext( spr_start_options, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
            global.moving_distance += 5;
        }
        else
        {
            alarm[2] = 1;
        }
    }
    else
    {
        draw_sprite_ext( spr_start_options, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
    }
}
else
{
    // draw the smaller sprite
    draw_sprite_ext( spr_start_options, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
}


// 4. draw credits (it would be smaller and gray color and a little transparent)

temp_index --;

if(temp_index &lt; 0)
{
    temp_index += number_of_point;
}

temp_x = vec_x[temp_index];
temp_y = vec_y[temp_index];
direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
image_angle = direction;

// draw it and resize, recolor
if(start_menu_position == index_credits)
{
    // (1) draw the menu description rectangle
    draw_set_color(color_description_box);
    draw_rectangle(0, 500, 800, 537, false);
    draw_set_color(c_black);
    draw_text(10, 505, "Our team!");
    
    // (2) draw the bigger sprite
    // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_credits

    if(index_when_press_enter == index_credits)
    {
        //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
        //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
        if(global.moving_distance &lt; 200)
        {
            difference_x = abs(x_of_center_of_circle - temp_x);
            difference_y = abs(y_of_center_of_circle - temp_y);
            difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
            destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
            destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
            draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            draw_sprite_ext( spr_start_credits, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
            global.moving_distance += 5;
        }
        else
        {
            alarm[3] = 1;
        }
    }
    else
    {
        draw_sprite_ext( spr_start_credits, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
    }
}
else
{
    // draw the smaller sprite
    draw_sprite_ext( spr_start_credits, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
}


// 5. draw quit (it would be smaller and gray color and a little transparent)

temp_index --;

if(temp_index &lt; 0)
{
    temp_index += number_of_point;
}

temp_x = vec_x[temp_index];
temp_y = vec_y[temp_index];
direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
image_angle = direction;

// draw it and resize, recolor
if(start_menu_position == index_quit)
{
    // (1) draw the menu description rectangle
    draw_set_color(color_description_box);
    draw_rectangle(0, 500, 800, 537, false);
    draw_set_color(c_black);
    draw_text(10, 505, "Quit the game.");
    
    // (2) draw the bigger sprite
    // if user press z or enter now, the sprite will be circled by the spr_start_bomb and QUIT

    if(index_when_press_enter == index_quit)
    {
        //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
        //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
        if(global.moving_distance &lt; 200)
        {
            difference_x = abs(x_of_center_of_circle - temp_x);
            difference_y = abs(y_of_center_of_circle - temp_y);
            difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
            destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
            destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
            draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            draw_sprite_ext( spr_start_quit, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
            global.moving_distance += 5;
        }
        else
        {
            alarm[4] = 1;
        }
    }
    else
    {
        draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
    }
}
else
{
    // draw the smaller sprite
    draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="90">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>index_when_press_enter = start_menu_position;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// menu going down
if(start_menu_position == number_of_menu_bars)
{
    start_menu_position = 1;
}
else if(start_menu_position &lt; number_of_menu_bars and start_menu_position &gt; 0)
{
    start_menu_position ++;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// menu going up
if(start_menu_position == 1)
{
    start_menu_position = number_of_menu_bars;
}
else if(start_menu_position &gt; 1 and start_menu_position &lt;= number_of_menu_bars)
{
    start_menu_position --;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>index_when_press_enter = start_menu_position;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>102,14</point>
    <point>80,80</point>
  </PhysicsShapePoints>
</object>
