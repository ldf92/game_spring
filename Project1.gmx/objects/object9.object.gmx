<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// if now the game is paused then we will draw the pause room
if(paused == true)
{
    // we need to calculate the points' coordinates
    // the coordinates of the points on the circle, stored in array
    vec_x = 0;
    vec_y = 0;
    
    // the angle between every two points
    angle_per_point = TOTAL_DEGREE_OF_CIRCLE / number_of_point;
    
    //index i
    i = 0;
    
    repeat (number_of_point)
    {
        // the point array should start from the toppest point on the circle
        angle = (i * angle_per_point + 90) * pi / HALF_DEGREE_OF_CIRCLE;
        vec_x[i] = radius * cos(angle) + x_of_center_of_circle;
        vec_y[i] = radius * sin(angle) + y_of_center_of_circle;
        i++;
    }
    
    //draw_text(20,40, pause_menu_position);
    //draw_text(20,80, vec_y[0]);
    
    
    
    // making the selected bar bigger and move to the center
    // draw_sprite_ext( sprite, subimg, x, y, xscale, yscale, rot, color, alpha );
    // e.g. draw_self = draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
    
    // the center of the circle (800, 170)
    // start game should be (440, 240), which is (vec_x[0], vec_y[0])
    // load game should be (450, 315), which is (vec_x[1], vec_y[1])
    
    // the color for the description box
    color_description_box = make_color_rgb(70,70,70);
    
    
    // 1. draw start game (it would be bigger and red color, and opaque)
    temp_index = pause_menu_position - 1;
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    
    //direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    //image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_resume)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Start a new game.");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_game
        if(index_when_press_enter == index_resume)
        {
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            /*
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_NewGame, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[0] = 1;
            }
            */
        }
        else
        {
            draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
    // 2. draw load game (it would be smaller and gray color and a little transparent)
    
    temp_index ++;
    
    if(temp_index &gt; number_of_menu_bars - 1)
    {
        temp_index = 0;
    }
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_load_game)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Load game from the old savings.");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_load
    
        if(index_when_press_enter == index_load_game)
        {/*
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_LoadGame, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[1] = 1;
            }*/
        }
        else
        {
            draw_sprite_ext( spr_start_LoadGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_LoadGame, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
    
    // 3. draw restart 
    
    temp_index ++;
    
    if(temp_index &gt; number_of_menu_bars - 1)
    {
        temp_index = 0;
    }
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_restart_this_stage)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Change settings.");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_options
        
        if(index_when_press_enter == index_restart_this_stage)
        {/*
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_options, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[2] = 1;
            }*/
        }
        else
        {
            draw_sprite_ext( spr_start_options, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_options, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
    
    // 4. draw options 
    
    temp_index ++;
    
    if(temp_index &gt; number_of_menu_bars - 1)
    {
        temp_index = 0;
    }
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_options)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Our team!");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and go to the room_credits
    
        if(index_when_press_enter == index_options)
        {/*
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_credits, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[3] = 1;
            }*/
        }
        else
        {
            draw_sprite_ext( spr_start_credits, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_credits, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
    
    // 5. draw main menu 
    
    temp_index ++;
    
    if(temp_index &gt; number_of_menu_bars - 1)
    {
        temp_index = 0;
    }
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_main_menu)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Quit the game.");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and QUIT
    
        if(index_when_press_enter == index_main_menu)
        {/*
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_quit, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[4] = 1;
            }*/
        }
        else
        {
            draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
     // 6. draw quit 
     
    temp_index ++;
    
    if(temp_index &gt; number_of_menu_bars - 1)
    {
        temp_index = 0;
    }
    
    temp_x = vec_x[temp_index];
    temp_y = vec_y[temp_index];
    direction = point_direction(temp_x, temp_y, x_of_center_of_circle, y_of_center_of_circle);    
    image_angle = direction;
    
    // draw it and resize, recolor
    if(pause_menu_position == index_quit)
    {
        // (1) draw the menu description rectangle
        draw_set_color(color_description_box);
        draw_rectangle(0, 500, 800, 537, false);
        draw_set_color(c_black);
        draw_text(10, 505, "Quit the game.");
        
        // (2) draw the bigger sprite
        // if user press z or enter now, the sprite will be circled by the spr_start_bomb and QUIT
    
        if(index_when_press_enter == index_quit)
        {/*
            //draw_sprite_ext( spr_start_bomb, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
            //draw_sprite_ext( spr_start_NewGame, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 ); 
            if(global.moving_distance &lt; 200)
            {
                difference_x = abs(x_of_center_of_circle - temp_x);
                difference_y = abs(y_of_center_of_circle - temp_y);
                difference_xy = sqrt(difference_x * difference_x + difference_y * difference_y);
                destination_x = temp_x + global.moving_distance * difference_x / difference_xy;
                destination_y = temp_y - global.moving_distance * difference_y / difference_xy;
                draw_sprite_ext( spr_start_bomb, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, image_blend, 1 );
                draw_sprite_ext( spr_start_quit, 0, destination_x, destination_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );   
                global.moving_distance += 5;
            }
            else
            {
                alarm[4] = 1;
            }*/
        }
        else
        {
            draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_big, image_xscale*scale_y_big, image_angle, c_red, 1 );
        }
    }
    else
    {
        // draw the smaller sprite
        draw_sprite_ext( spr_start_quit, 0, temp_x, temp_y, image_xscale*scale_x_small, image_xscale*scale_y_small, image_angle, c_gray, 0.8 );
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
